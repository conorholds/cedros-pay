"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const o=require("@solana/web3.js"),w=require("@solana/spl-token"),t=require("./CedrosContext-C26DlvLF.js"),h=require("./index-WcOlBYZJ.js");class p{connection;cluster;endpoint;allowUnknownMint;rpcRateLimiter=t.createRateLimiter({maxRequests:50,windowMs:6e4});rpcCircuitBreaker=t.createCircuitBreaker({failureThreshold:5,timeout:1e4,name:"solana-rpc"});constructor(r="mainnet-beta",e,n=!1){this.cluster=r,this.endpoint=e,this.allowUnknownMint=n,this.connection=this.createConnection()}createConnection(){const r=this.endpoint??o.clusterApiUrl(this.cluster);return new o.Connection(r,"confirmed")}transformRpcError(r){const e=r instanceof Error?r.message:typeof r=="string"?r:String(r);return e.includes("403")||e.includes("Access forbidden")?new Error("Public Solana RPC access denied. Please configure a custom RPC endpoint (e.g., from Helius, QuickNode, or Alchemy) in your CedrosProvider config using the solanaEndpoint option."):e.includes("429")||e.includes("Too Many Requests")?new Error("Solana RPC rate limit exceeded. Please configure a custom RPC endpoint with higher limits in your CedrosProvider config using the solanaEndpoint option."):r instanceof Error?r:new Error(e)}async buildTransaction(r){const{requirement:e,payerPublicKey:n,blockhash:a}=r;if(!e||!e.payTo)throw new Error("Invalid requirement: missing payTo");t.getLogger().debug("[WalletManager] Building transaction for resource:",e.resource);const i=new o.Transaction,u=this.resolveAmountInMinorUnits(e),c=e.asset;if(!c)throw new Error("asset is required in x402 requirement");const l=t.validateX402Asset(c,e.resource,this.allowUnknownMint);if(!l.isValid&&l.error)throw new Error(l.error);l.warning&&t.getLogger().warn(l.warning);const y=new o.PublicKey(c),m=await w.getAssociatedTokenAddress(y,n);if(!this.rpcRateLimiter.tryConsume())throw new Error("RPC rate limit exceeded. Please try again in a moment.");let d;try{d=await this.rpcCircuitBreaker.execute(async()=>await t.retryWithBackoff(async()=>await this.connection.getAccountInfo(m),{...t.RETRY_PRESETS.QUICK,name:"rpc-get-account-info"}))}catch(s){throw s instanceof t.CircuitBreakerOpenError?new Error("Solana RPC service is temporarily unavailable. Please try again in a few moments."):this.transformRpcError(s)}if(!d)throw new Error("Payer is missing an associated token account for this mint");let f;try{f=e.extra?.recipientTokenAccount?new o.PublicKey(e.extra.recipientTokenAccount):new o.PublicKey(e.payTo)}catch(s){throw t.getLogger().warn("[WalletManager] Failed to resolve recipient address:",s),new Error("We are currently unable to process payment, please try again later")}if(i.add(w.createTransferInstruction(m,f,n,u)),e.extra?.memo){const s=new o.TransactionInstruction({keys:[],programId:new o.PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"),data:Buffer.from(e.extra.memo,"utf8")});i.add(s)}let g;if(a)g=a;else{if(!this.rpcRateLimiter.tryConsume())throw new Error("RPC rate limit exceeded. Please try again in a moment.");try{g=(await this.rpcCircuitBreaker.execute(async()=>await t.retryWithBackoff(async()=>await this.connection.getLatestBlockhash(),{...t.RETRY_PRESETS.QUICK,name:"rpc-get-blockhash"}))).blockhash}catch(s){throw s instanceof t.CircuitBreakerOpenError?new Error("Solana RPC service is temporarily unavailable. Please try again in a few moments."):this.transformRpcError(s)}}return i.recentBlockhash=g,e.extra?.feePayer?i.feePayer=new o.PublicKey(e.extra.feePayer):i.feePayer=n,i}resolveAmountInMinorUnits(r){const e=r.maxAmountRequired;if(!/^\d+$/.test(e))throw new Error("Invalid maxAmountRequired in requirement: must be a non-negative integer string");const n=BigInt(e);if(n<=0n)throw new Error("Invalid maxAmountRequired in requirement");return n}buildPaymentPayload(r){const{requirement:e,signedTx:n,payerPublicKey:a}=r;return{x402Version:0,scheme:e.scheme,network:e.network,payload:{signature:n.signature,transaction:n.serialized,payer:a.toString(),memo:e.extra?.memo,recipientTokenAccount:e.extra?.recipientTokenAccount}}}async signTransaction(r){const{transaction:e,signTransaction:n}=r;t.getLogger().debug("[WalletManager] Requesting wallet to sign transaction");const a=await n(e),i=a.serialize(),u=a.signatures[0]?.signature;if(!u)throw new Error("Signed transaction missing signature");const c=h.bs58.encode(u);return t.getLogger().debug("[WalletManager] Transaction signed with signature:",c.substring(0,20)+"..."),{serialized:t.gBase64.fromUint8Array(i),signature:c}}deserializeTransaction(r){try{const e=t.gBase64.toUint8Array(r);return o.Transaction.from(e)}catch(e){throw new Error(`Failed to deserialize transaction: ${t.formatError(e,"Unknown error")}`)}}async partiallySignTransaction(r){const{transaction:e,signTransaction:n,blockhash:a}=r;a&&e.recentBlockhash!==a&&(e.recentBlockhash=a);const i=await n(e),u=i.signatures[0]?.signature;if(u){const l=h.bs58.encode(u);t.getLogger().debug("[WalletManager] Partially signed with signature:",l.substring(0,20)+"...")}const c=i.serialize({requireAllSignatures:!1,verifySignatures:!1});return t.gBase64.fromUint8Array(c)}async getBalance(r){if(!this.rpcRateLimiter.tryConsume())throw new Error("RPC rate limit exceeded. Please try again in a moment.");try{return await this.rpcCircuitBreaker.execute(async()=>await t.retryWithBackoff(async()=>await this.connection.getBalance(r),{...t.RETRY_PRESETS.QUICK,name:"rpc-get-balance"}))/o.LAMPORTS_PER_SOL}catch(e){throw e instanceof t.CircuitBreakerOpenError?new Error("Solana RPC service is temporarily unavailable. Please try again in a few moments."):this.transformRpcError(e)}}async verifyTransaction(r){if(!this.rpcRateLimiter.tryConsume())throw new Error("RPC rate limit exceeded for transaction verification");try{return!!(await this.rpcCircuitBreaker.execute(async()=>await t.retryWithBackoff(async()=>await this.connection.getSignatureStatus(r),{...t.RETRY_PRESETS.QUICK,name:"rpc-verify-tx"}))).value?.confirmationStatus}catch(e){return e instanceof t.CircuitBreakerOpenError&&t.getLogger().warn("[WalletManager] Circuit breaker OPEN - cannot verify transaction"),!1}}}exports.WalletManager=p;
